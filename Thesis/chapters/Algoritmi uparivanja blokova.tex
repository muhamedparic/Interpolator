\section{Uvod}
Prva klasa algoritama koje \cj emo prou\ch avati kre\cj u od iste osnovne ideje: Podijeliti prvi frejm na blokove, za svaki blok prona\cj i vektor pomaka iz prvog u drugi frejm, te primijeniti jedan dio tog vektora pomaka na blok.
Ako nam je cilj samo kreirati jedan novi frejm izme\dj u svaka dva postoje\cj a, svaki blok \cj emo pomjeriti du\zh\ pola izra\ch unatog vektora pomaka. Ako nam je cilj interpolirati dva frejma izme\dj u dva postoje\cj a, blok \cj emo 
pomjeriti du\zh\ jedne tre\cj ine vektora pomaka za prvi, i dvije tre\cj ine za drugi interpolirani frejm, itd. Cilj slijede\cj ih algoritama jeste uparivanje blokova prvog frejma sa blokom iste veli\ch ine u drugom frejmu. Me\dj utim,
postoji nekoliko pitanja na koja moramo odgovoriti prije nego \sh to mo\zh emo primijeniti ove algoritme:

\begin{itemize}
	\item Koju veli\ch inu bloka \cj emo koristiti?
	\item Koliki \cj e biti prozor pretrage, odnosno koliko \cj e se svaki blok mo\cj i maksimalno pomjeriti izme\dj u prvog i drugog frejma?
	\item Koji je kriterij sli\ch nosti dva bloka?
	\item Kako odrediti uspje\sh nost uparivanja?
\end{itemize}

U praksi se koriste blokovi veli\ch ine 16x16 piksela, te prozor pretrage veli\ch ine 30x30 piksela. To zna\ch i da pretpostavljamo da se izme\dj u dva susjedna frejma blokovi ne\cj e pomjeriti vi\sh e od 7 piksela u bilo kojem od 4
kardinalna smjera. To nam daje 225 mogu\cj ih lokacija za svaki blok. Naravno, ne postoji definitivna, optimalna veli\ch ina bloka ili prozora pretrage za sve slu\ch ajeve. Manje blokove je br\zh e uporediti, ali je njihov broj ve\cj i,
te je ve\cj a vjerovatno\cj a da \cj e dva bloka biti slu\ch ajno veoma sli\ch na. Ve\cj i prozor pretrage nam omogu\cj ava pronala\zh enje ispravnih vektora pomaka i u slu\ch aju kada se desi pomak ve\cj i od 7 piksela, ali
zna\ch ajno pove\cj ava vrijeme potrebno za izra\ch unavanje te, sli\ch no kao u slu\ch aju blokova, pove\cj anjem prozora pretrage se pove\cj ava i vjerovatno\cj a uparivanja dva bloka koji su sli\ch ni, ali zapravo ne
predstavljaju isti blok. U svim slijede\cj im algoritmima \cj emo koristiti blokove i prozore pretrage navedene veli\ch ine.

Sljede\cj e pitanje se ti\ch e kriterija sli\ch nosti dva bloka. Svaki blok je sastavljen od 256 piksela, koji se sastoje od 3 komponente: crvene, zelene, i plave. Svaka komponenta ima cjelobrojnu ja\ch inu u rasponu od 0 do 255, uklju\ch ivo.
Za upore\dj ivanje blokova se prvo pikseli pretvore u crno-bijele, sa jednom komponentom koja predstavlja ja\ch inu bijele boje piksela.
% Objasniti zasto
Kori\sh teni kriteriji sli\ch nosti blokova su veoma jednostavni. Jedan je  \textit{Mean Absolute Difference (MAD)}, odnosno \textit{srednja apsolutna razlika}. Ova mjera nije ni\sh ta drugo nego suma apsolutnih vrijednosti razlika
ja\ch ina odgovaraju\cj ih piksela u blokovima, podijeljena sa veli\ch inom bloka. Drugim rije\ch ima, zadana je formulom
$$
MAD = \frac{1}{N^2}\sum_{i=0}^{N-1}\sum_{j=0}^{N-1}|A_{ij}-B_{ij}|
$$

Pri \ch emu \textit{N} predstavlja visinu i \sh irinu bloka (u na\sh em slu\ch aju 16), dok $A_{ij}$ i $B_{ij}$ predstavljaju vrijednosti piksela na koordinatama \textit{i,j} (sa po\ch etkom u gornjem lijevom uglu bloka) prvog,
odnosno drugog razmatranog bloka. 

Druga, veoma sli\ch na mjera jeste \textit{Mean Squared Error (MSE)}, odnosno \textit{srednji kvadrat gre\sh ke}. Umjesto uzimanja apsolutne vrijednosti razlika piksela, ova mjera kvadrira razlike piksela, \ch ime se vi\sh e
ka\zh njavaju ve\cj e razlike. \textit{MSE} je zadana formulom
$$
MSE = \frac{1}{N^2}\sum_{i=0}^{N-1}\sum_{j=0}^{N-1}(A_{ij}-B_{ij})^2
$$

Mi \cj emo ove funkcije ubudu\cj e zvati zajedni\ch kim imenom \textit{funkcije cijene}. Cilj svih algoritama u ovom poglavlju jeste minimizacija funkcije cijene, bilo \textit{MAD} ili \textit{MSE}.

Jo\sh\ jedno veoma va\zh no podru\ch je primjene algoritama uparivanja blokova (i zapravo podru\ch je gdje se najvi\sh e primjenjuju) jeste kompresija video sekvenci. U dijelu vezanom za osnovne algoritme i ARPS,
obra\dj uju se algoritmi koji su kori\sh teni u standardima H.261, H.262 i H.263. U novijim standardima (pri \ch emu je najnoviji H.265, \ch ija je prva verzija iza\sh la 2013. godine) kori\sh teni su napredniji algoritmi, koji u
ovom radu ne\cj e biti obra\dj eni.

\section{Osnovni algoritmi}
Sada \cj emo se osvrnuti na neke od osnovnih algoritama uparivanja blokova. Pretpostavit \cj emo da su blokovi veli\ch ine 16x16 piksela, a prozori pretrage veli\ch ine 30x30 piksela, te da su svi pikseli monohromatski
(crno-bijeli). Od svih slijede\cj ih algoritama, samo prvi pronalazi optimalno uparivanje. Svi ostali ostali algoritmi su aproksimacije. Preciznije re\ch eno, postoji 225 mogu\cj ih lokacija gdje se po\ch tni blok mo\zh e nalaziti
u prozoru pretrage. Defini\sh imo matricu $C_{15x15}$, pri \ch emu svakom elementu matrice $C$ odgovara vrijednost funkcije cijene (\textit{MAD} ili \textit{MSE}) koju dobijemo ako postavimo blok na to mjesto u prozoru pretrage
(drugim rije\ch ima, elementu \textit{1,1} odgovara vrijednost funkcije cijene koju dobijemo ako blok postavimo u gornji lijevi ugao prozora pretrage, pomjeranjem bloka dobijamo druge vrijednosti matrice).
Aproksimativni algoritmi pretpostavljaju da ova matrica ima jednu najmanju (optimalnu) vrijednost, i da vrijednosti elemenata matrice monotono rastu kako se udaljavamo od ovog elementa. Kontinualni analogon ove osobine
bi bila funkcija 2 realne promjenljive koja ima samo jedan lokalni minimum, koji je ujedno i globalni minimum. Za funkciju koja ima ovu osobinu ka\zh emo da je \textit{unimodalna}. U slu\ch aju kad ova osobina postoji,
mo\zh emo prona\cj i minimalnu vrijednost matrice jednostavnim spu\sh tanjem po gradijentu, odnosno, po\ch ev\sh i od proizvoljnog po\ch etnog elementa, u svakom koraku pre\dj emo na bilo koji od manjih elemenata dok ne
do\dj emo do nekog koji je manji od svih svojih susjednih elemenata.

Naravno, ne postoji ni\sh ta da nam garantuje ovu osobinu, \sh to zna\ch i da \cj e aproksimativni algoritmi samo u rijetkim slu\ch ajevima prona\cj i optimalno rje\sh enje.
% Dodati dio o PSNR

\subsection{Potpuna pretraga}
Ovaj algoritam se zasniva na potpunom pretra\zh ivanju svih mogu\cj ih lokacija za blok, te pronala\zh enju lokacije koja daje najmanju vrijednost funkcije cijene. Postoji 225 mogu\cj ih lokacija za blok unutar prozora pretrage,
a za izra\ch unavanje vrijednosti funkcije cijene moramo uporediti $16 * 16 = 256$ piksela. To nam daje $225 * 256 = 57600$ upore\dj ivanja piksela po bloku. HD video (dimenzija 1280x720 piksela) sadr\zh i frejmove koji se
sastoje od 3600 blokova, \sh to nam ukupno daje preko 200 miliona upore\dj ivanja piksela za svaki frejm video sekvence. Tako da nije te\sh ko vidjeti za\sh to se ovaj algoritam ne koristi u praksi.

\subsection{Trostepena pretraga}
Trostepena pretraga se oslanja na osobinu unimodalnosti matrice vrijednosti funkcije cijene. Ovaj algoritam je ovdje kori\sh ten isklju\ch ivo kao uvod, jer ostvaruje veoma slabe rezultate u praksi. Algoritam je mnogo br\zh i
od potpune pretrage te koristi sli\ch ne tehnike kao bolji algoritmi koji \cj e biti obra\dj eni u narednim dijelovima.

Neka je zadan prozor pretrage veli\ch ine 30x30 piksela i blok veli\ch ine 16x16 piksela. Trostepena pretraga radi tako \sh to u svakom koraku izra\ch una funkciju cijene bloka na 9 lokacija u prozoru pretrage. Tih 9 lokacija su
trenutni centar i sve kombinacije lokacija koje dobijemo ako blok pomjerimo za \textit{-S, 0} ili \textit{S} piksela po x i y osama (postoji 9 kombinacija, od kojih je jedna \textit{(0, 0)}, \sh to predstavlja na\sh\ centar).
\textit{S} predstavlja trenutnu \textit{veli\ch inu koraka}. Nakon izra\ch unavanja funkcije cijene na svih 9 lokacija, izaberemo najbolju (tj. lokaciju koja daje najmanju vrijednost funkcije cijene), nju odredimo za novi centar, i 
smanjimo \textit{S} na jednu polovinu trenutne vrijednosti. U prvom koraku, \textit{S} \cj e imati vrijednost 4, u drugom 2, a u tre\cj em 1, dok \cj e centar u prvom koraku predstavljati stvarni centar prozora pretrage. 
S obzirom da se na po\ch etku blok nalazi 7 piksela daleko od ivica prozora pretrage, a u 3 koraka (sa pomakom od 4, 2 i 1 pikselom) se mogu\cj e pomjeriti najvi\sh e ta\ch no 7 piksela, blok mo\zh e zauzeti bilo koju 
poziciju u prozoru pretrage.

U svakom od 3 koraka, imamo 9 razli\ch itih mogu\cj ih pozicija bloka, tako da izgleda da moramo izra\ch unati funkciju cijene bloka 27 puta. Me\dj utim, centar u drugom i tre\cj em koraku je ve\cj\ izra\ch unat u prethodnom
koraku, tako da je zapravo potrebno izra\ch unati samo 25 razli\ch itih funkcija pretrage, \sh to je 9 puta manje od 225 kod potpune pretrage, \sh to naravno predstavlja veoma zna\ch ajno ubrzanje. Me\dj utim, kao \sh to je
prije re\ch eno, ovaj algoritam generalno ne izra\ch unava zadovoljavaju\cj e vektore pomaka, tako da se u praksi i ne koristi.
%Slika rada algoritma

\subsection{\CH etverostepena pretraga}

\subsection{Dijamantna pretraga}

\section{Adaptive Rood Pattern Search - ARPS}

\section{Fazna korelacija}